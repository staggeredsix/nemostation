"""Convenience HTTP client for interacting with the Daystrom Memory Lattice server."""
from __future__ import annotations

from typing import Any, Dict, Optional

import requests


class DMLClient:
    """Small wrapper around the public Daystrom Memory Lattice HTTP API.

    Parameters
    ----------
    base_url:
        Base URL of the running DML service. Trailing slashes are trimmed
        automatically.
    timeout:
        Default timeout in seconds applied to all HTTP requests. Set to ``None``
        to disable timeouts altogether.
    session:
        Optional pre-configured :class:`requests.Session` object. This is
        primarily useful in larger applications that need to customise retry
        policies or authentication. When omitted a new session will be created.
    """

    def __init__(
        self,
        base_url: str = "http://localhost:8000",
        *,
        timeout: Optional[float] = 30.0,
        session: Optional[requests.Session] = None,
    ) -> None:
        self.base_url = base_url.rstrip("/")
        self.timeout = timeout
        self._session = session or requests.Session()

    # ------------------------------------------------------------------
    # Public API surface
    # ------------------------------------------------------------------
    def ingest(self, text: str, *, meta: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Ingest a raw text fragment into the lattice."""

        payload: Dict[str, Any] = {"text": text}
        if meta is not None:
            payload["meta"] = meta
        response = self._session.post(
            self._url("/ingest"),
            json=payload,
            timeout=self.timeout,
        )
        return self._json(response)

    def reinforce(self, text: str, *, meta: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Reinforce an insight after generating a response."""

        payload: Dict[str, Any] = {"text": text}
        if meta is not None:
            payload["meta"] = meta
        response = self._session.post(
            self._url("/reinforce"),
            json=payload,
            timeout=self.timeout,
        )
        return self._json(response)

    def query(self, prompt: str) -> Dict[str, Any]:
        """Run a full retrieval + generation loop for ``prompt``."""

        response = self._session.post(
            self._url("/query"),
            json={"prompt": prompt},
            timeout=self.timeout,
        )
        return self._json(response)

    def stats(self) -> Dict[str, Any]:
        """Fetch diagnostic statistics for the running lattice."""

        response = self._session.get(self._url("/stats"), timeout=self.timeout)
        return self._json(response)

    def knowledge(self) -> Dict[str, Any]:
        """Return the knowledge report generated by the service."""

        response = self._session.get(self._url("/knowledge"), timeout=self.timeout)
        return self._json(response)

    # ------------------------------------------------------------------
    # Lifecycle helpers
    # ------------------------------------------------------------------
    def close(self) -> None:
        """Release the underlying HTTP session."""

        self._session.close()

    def __enter__(self) -> "DMLClient":  # pragma: no cover - trivial
        return self

    def __exit__(self, *_exc: object) -> None:  # pragma: no cover - trivial
        self.close()

    # ------------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------------
    def _url(self, path: str) -> str:
        return f"{self.base_url}{path}"

    @staticmethod
    def _json(response: requests.Response) -> Dict[str, Any]:
        response.raise_for_status()
        data = response.json()
        if not isinstance(data, dict):
            raise ValueError("DML server returned a non-object JSON payload")
        return data


__all__ = ["DMLClient"]
